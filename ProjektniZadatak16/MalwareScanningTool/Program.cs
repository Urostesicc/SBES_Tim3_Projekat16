using AuditManager;
using CertificateManager;
using Contracts;
using SecurityManager;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IdentityModel.Policy;
using System.IO;
using System.Linq;
using System.Security.Cryptography.X509Certificates;
using System.Security.Principal;
using System.ServiceModel;
using System.ServiceModel.Description;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Xml.Serialization;

namespace MalwareScanningTool
{
    class Program
    {
        static void Main(string[] args)
        {
            //string name = "mst";
            string name = Formatter.ParseName(WindowsIdentity.GetCurrent().Name);
            Console.WriteLine(name);

            NetTcpBinding bindingCL = new NetTcpBinding();
            string addressCL = "net.tcp://localhost:9999/Service";

            //Windows Authentification
            bindingCL.Security.Mode = SecurityMode.Transport;
            bindingCL.Security.Transport.ClientCredentialType = TcpClientCredentialType.Windows;
            bindingCL.Security.Transport.ProtectionLevel = System.Net.Security.ProtectionLevel.EncryptAndSign;

            ServiceHost hostCL = new ServiceHost(typeof(MalwareScanningTool));
            hostCL.AddServiceEndpoint(typeof(IClientCommunication), bindingCL, addressCL);

            //Defining CustomAuthorizationManager as the preffered one.
            hostCL.Authorization.ServiceAuthorizationManager = new CustomAuthorizationManager();

            //Defining our principal settings.
            hostCL.Authorization.PrincipalPermissionMode = PrincipalPermissionMode.Custom;
            List<IAuthorizationPolicy> policies = new List<IAuthorizationPolicy>();
            policies.Add(new CustomAuthorizationPolicy());
            hostCL.Authorization.ExternalAuthorizationPolicies = policies.AsReadOnly();

            ServiceSecurityAuditBehavior newAudit = new ServiceSecurityAuditBehavior();
            newAudit.AuditLogLocation = AuditLogLocation.Application;
            newAudit.ServiceAuthorizationAuditLevel = AuditLevel.SuccessOrFailure;

            hostCL.Description.Behaviors.Remove<ServiceSecurityAuditBehavior>();
            hostCL.Description.Behaviors.Add(newAudit);

            string srvCertCN = "ids";

            NetTcpBinding bindingIDS = new NetTcpBinding();
            bindingIDS.Security.Transport.ClientCredentialType = TcpClientCredentialType.Certificate;
            X509Certificate2 srvCert = CertManager.GetCertificateFromStorage(StoreName.My, StoreLocation.LocalMachine, srvCertCN);
            EndpointAddress addressIDS = new EndpointAddress(new Uri("net.tcp://localhost:9998/IDS"),
                                      new X509CertificateEndpointIdentity(srvCert));

            hostCL.Open();

            Console.WriteLine("Service is opened. Press <enter> to finish...");

            List<Threat> threatList = new List<Threat>();

            bool exit = false;
            Alarm alarm = new Alarm();
            DateTime timestamp = new DateTime();
            AlarmCriticality criticality = AlarmCriticality.Information;

            //AddCurrentProcessesToWL();

            using (MalwareScanningTool proxy = new MalwareScanningTool(bindingIDS, addressIDS))
            {
                while (!exit)
                {
                    Thread.Sleep(10000);

                    threatList = Scan(threatList);
                    foreach (Threat threat in threatList)
                    {
                        if (threat.TimesDetected >= 3)
                        {
                            criticality = AlarmCriticality.Critical;
                        }
                        else if (threat.TimesDetected == 2)
                        {
                            criticality = AlarmCriticality.Warning;
                        }
                        else if (threat.TimesDetected == 1)
                        {
                            criticality = AlarmCriticality.Information;
                        }
                        timestamp = DateTime.Now;
                        alarm = new Alarm(1, threat.Process.ProcessName, criticality, timestamp);
                        proxy.UpdateIDS(alarm);
                        Audit.ThreatDetected(threat.Process.ProcessName, criticality, timestamp);
                    }
                    Console.WriteLine("Checking for threats.");
                    Console.WriteLine();
                }
            }

            Console.ReadLine();

            hostCL.Close();
        }

        private static void AddCurrentProcessesToWL()
        {
            string whitelistPath = @"..\..\Whitelist.xml";
            XmlSerializer serializer = new XmlSerializer(typeof(List<ConfigurationEntry>));
            List<ConfigurationEntry> entryList = new List<ConfigurationEntry>();

            ConfigurationEntry entry = null;

            if (File.Exists(whitelistPath))
            {
                using (FileStream stream = File.OpenRead(whitelistPath))
                {
                    try
                    {
                        entryList = (List<ConfigurationEntry>)serializer.Deserialize(stream);
                    }
                    catch (Exception e)
                    {
                        //Avoiding the empty whitelist exception.
                    }
                }
                int cnt = entryList.Count;
                Process[] processes = Process.GetProcesses();

                foreach (Process process in processes)
                {
                    List<string> users = new List<string>();
                    users.Add(process.StartInfo.UserName);
                    entry = new ConfigurationEntry(cnt++, process.ProcessName, users);
                    entryList.Add(entry);
                }

                using (var stream = File.Create(whitelistPath))
                {
                    serializer.Serialize(stream, entryList);
                    Console.WriteLine("Added intial processes to the whitelist.");

                    try
                    {
                        //Audit.ModifyEntrySuccess();
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }
            }
        }

        private static List<Threat> Scan(List<Threat> threatList)
        {
            string whitelistPath = @"..\..\Whitelist.xml";

            Process[] duplicateProcesses = Process.GetProcesses();
            List<Process> processes = new List<Process>();

            bool found = false;

            foreach (Process process in duplicateProcesses)
            {
                foreach (Process proc in processes)
                {
                    if (process.ProcessName.Equals(proc.ProcessName))
                    {
                        found = true;
                        break;
                    }
                    found = false;
                }
                if (!found)
                {
                    processes.Add(process);
                }
            }

            XmlSerializer serializer = new XmlSerializer(typeof(List<ConfigurationEntry>));
            List<ConfigurationEntry> entryList = new List<ConfigurationEntry>();

            if (File.Exists(whitelistPath))
            {
                using (FileStream stream = File.OpenRead(whitelistPath))
                {
                    try
                    {
                        entryList = (List<ConfigurationEntry>)serializer.Deserialize(stream);
                    }
                    catch (Exception e)
                    {
                        //Avoiding the empty database exception.
                    }
                }

                List<Threat> proxyThreatList = new List<Threat>();
                foreach (Threat threat in threatList)
                {
                    proxyThreatList.Add(threat);
                }

                foreach (Process process in processes)
                {
                    foreach (ConfigurationEntry entry in entryList)
                    {
                        if (process.ProcessName.Equals(entry.ProcessName))
                        {
                            foreach (Threat threat in proxyThreatList)
                            {
                                if (threat.Process.ProcessName.Equals(entry.ProcessName))
                                {
                                    threatList.Remove(threat);
                                }
                            }
                            break;
                        }
                    }
                }

                foreach (Process process in processes)
                {
                    found = false;
                    foreach (ConfigurationEntry entry in entryList)
                    {
                        if (process.ProcessName.Equals(entry.ProcessName))
                        {
                            found = true;
                            break;
                        }
                        found = false;
                    }
                    if (!found)
                    {
                        Console.WriteLine(process.ProcessName);
                        foreach (Threat threat in threatList)
                        {
                            if (threat.Process.ProcessName.Equals(process.ProcessName))
                            {
                                found = true;
                                threat.TimesDetected++;
                                break;
                            }
                        }
                        if (!found)
                        {
                            threatList.Add(new Threat(process, 1));
                        }
                    }
                }
            }

            return threatList;
        }
    }
}